

# 一些总结：


# 对于 debian的 硬盘安装方法，经常会失败，最可靠的方法就是将 iso 直接 dd 到 usb 整个盘或 usb 的某个分区的方法。
# 采用gpt分区表，以便支持大硬盘和更多的主分区。

# 但是对于各种live iso，则采用 iso dd 的方法到整个硬盘/usb
# 或硬盘/usb的某个主分区，也许都是可以的。
# 或者 采用 loopback 的方法也有可能。

# 所有这些方法的核心是 如果能够保证 iso 上的 相关配置被正确的调用--恰如刻盘的情况那样，就会有成功的可能。 
# 如果能够保证 相关配置被正确的调用的情况下， 用 chainloader 的方法，将会获得如刻盘一样的效果。 

# 关于 window 10 安装，也是非常简单的：
# 
# 在 硬盘或usb上，做一个ntfs分区，将 iso的内容cp上去，然后，以 efi 模式引导，该ntfs 分区自然就是
# 可以引导安装的。
# 
# 或者，进入 grub2 的命令行，用下面的方法也可以：
# 
# set root=(hdx,y)
# chainloader /efi/boot/bootx64.efi



# 从那个盘启动，那个盘就是 hd0.


# ====================================

# 12-
# 使用regexp模块：
# https://www.rmprepusb.com/tutorials/grub2_tutorial137
# 一些摘录：
# Scripting
# Loosely follows bash shell
# Useful functions and notes regular expressions

# function pathname { regexp -s 2:"$2" '^(\(.*\))?(/.*)$' "$1"; } # /_ISO/ubuntu 64.iso
# function devname { regexp -s "$2" '^(\(.*\)).*$' "$1"; } # (hd0,msdos2)
# function pathonly { regexp -s 2:"$2" '^(\(.*\))?(.*/)*' "$1"; } # /_ISO/
# function getext { regexp -s 3:"$2" '^(.*/)*(.*)\.(.*)$' "$1"; } # iso
# function getfname { regexp -s 2:"$2" '(.*)/+(.*)' "$1"; } # ubuntu 64.iso
# function gethdnum { regexp -s 2:"$2" '^(.*)hd(.*),' "$1"; } # 0
# function getdev { regexp -s 2:"$2" '^(.*)\((.*),' "$1"; } # hd0




# usage where $file = (hd0,msdos1)/_ISO/DIR/some file name with spaces.iso
# # set isopath to the fullpath without device name

# pathname "$file" isopath # make sure double-quotes around $file - this sets the isopath variable to /_ISO/DIR/some file name with spaces.iso

# 2: = get second match value, 3: = 3rd matched value
# ^ = start at beginning
# $ = up to end of line

# If looking for ( or ) then must precede with \

# (\(.*\))? = look for ( then anything then ) ? is zero or more of preceding match which is enclosed in ( )
# (/.*)$ = look for / followed by any chars up to end of line

# (.+/)* = look for 1 or more chars up to / any number of times
# (*+)\. = look for 0 or more chars followed by .
# (.+)$ = look for all chars till end of line


# e.g. regexp -s 2:"$2" '^(.*)\((.*),'

# ^ = start at beginning of line, look for any number of chars (.*), look for open parenthesis (, look for any number chars (.*), look for comma , - return 2nd match in parentheses as $2.


# testing regexp from the grub2 command line

# unset fred ; regexp -s 2:"fred" 'test regexp here' "$file" ; echo $fred
# # if filename does not contain ubuntu then abort
# if ! regexp '(.*)[uU][bB][uU][nN][tT][uU]' "$myfname" ; then continue ; fi
 

# https://lists.gnu.org/archive/html/grub-devel/2016-09/msg00018.html
# 下面这个文件中也有许多高级的用法：
# /media/werner/7ac9245c-3441-4dc2-a6e8-2267bea3c29f/grub/grub.git/docs/autoiso.cfg


# 13- probe
#https://www.gnu.org/software/grub/manual/grub/grub.html

#https://askubuntu.com/questions/228031/how-do-you-get-a-uuid-from-a-a-device-on-the-grub2-prompt

#Programmatically, this can be queried with the probe command, e.g.:

#probe --fs-uuid (hd0,gpt6)

#The result can also be assigned to a variable with --set:

#probe --set devuuid --fs-uuid (hd0,gpt6)
#echo $devuuid


#http://www.jinbuguo.com/linux/grub.cfg.html
#probe [--set var] --driver|--partmap|--fs|--fs-uuid|--label device
#    提取"device"设备的特定信息。如果使用了 --set 选项，则表示将提取的结果保存在"var"变量中，否则将提取的结果直接显示出来。



# 14- source / configfile
#configfile file

#    将"file"作为配置文件加载。如果"file"中定义了菜单项，那么立即显示一个包含它们的菜单。

#    [注意]"file"文件对环境变量所做的任何变更都将在从此文件返回后失效。

#source file

#    直接将"file"文件的内容插入到当前位置。与"configfile"不同，此命令既不切换执行环境，也不会显示一个新的菜单。



# 15-

#https://www.gnu.org/software/grub/manual/grub/grub.html#cmp

#16.3.65 search

#Command: search [--file|--label|--fs-uuid] [--set [var]] [--no-floppy] name

#    Search devices by file (-f, --file), filesystem label (-l, --label), or filesystem UUID (-u, --fs-uuid).

#    If the --set option is used, the first device found is set as the value of environment variable var. The default variable is ‘root’.

#    The --no-floppy option prevents searching floppy devices, which can be slow.

#    The ‘search.file’, ‘search.fs_label’, and ‘search.fs_uuid’ commands are aliases for ‘search --file’, ‘search --label’, and ‘search --fs-uuid’ respectively. 

# 关于 --hint

#grub.git$ grep -r -- '--hint' *

#可以观察源码发现相关的说明：
#grub.git$ cat grub-core/commands/search_wrap.c


#https://unix.stackexchange.com/questions/115555/what-does-the-hint-option-in-grub2s-search-command-do/126601#126601

#This is not described in the GRUB Manual but there is documentation to be found in GRUB itself (search --help on the GRUB shell):

#--hint
#    First try the device HINT.
#    If HINT ends in comma, also try subpartitions

#--hint-ieee1275
#    First try the device HINT if currently running on IEEE1275.
#    If HINT ends in comma, also try subpartitions

#--hint-bios
#    First try the device HINT if currently running on BIOS.
#    If HINT ends in comma, also try subpartitions

#--hint-baremetal
#    First try the device HINT if direct hardware access is supported.
#    If HINT ends in comma, also try subpartitions

#--hint-efi
#    First try the device HINT if currently running on EFI.
#    If HINT ends in comma, also try subpartitions

#--hint-arc
#    First try the device HINT if currently running on ARC.
#    If HINT ends in comma, also try subpartitions


# 这里给出的 search --file 例子，

# 要支持 通配符，都需要先加载 regexp 模块。 


#http://blog.sciencenet.cn/blog-2353794-881814.html
#http://www.jinbuguo.com/linux/grub.cfg.html

#启动某个引导文件：
#menuentry "启动 G4D"{
#search --file /grldr --set=root
#insmod ntldr
#ntldr /grldr
#}




#https://www.gnu.org/software/grub/manual/grub/grub.html#Multi_002dboot-manual-config
#https://www.gnu.org/software/grub/manual/grub/grub.html#Embedded-configuration





#https://www.gnu.org/software/grub/manual/grub/grub.html#test
#-d file

#    file exists and is a directory 
#-e file

#    file exists 
#-f file

#    file exists and is not a directory 
#-s file

#    file exists and has a size greater than zero 
#-n string

#    the length of string is nonzero 
#string

#    string is equivalent to -n string 
#-z string

#    the length of string is zero 





# $ sudo blkid -o export | awk '/LABEL=/ { if ( a ) print a, $0 }  /TYPE=iso9660/ {a=$0 } '
# TYPE=iso9660 LABEL=SYSRCD603
# TYPE=iso9660 LABEL=Debian\ 10.1.0\ amd64\ 1
# TYPE=iso9660 LABEL=CentOS-8-BaseOS-x86_64
# TYPE=iso9660 LABEL=ARCH_201910
# TYPE=iso9660 LABEL=Gentoo-amd64-hardened-nomultilib
# TYPE=iso9660 LABEL=Kubuntu\ 19.10\ amd64
# TYPE=iso9660 LABEL=Deepin\ 15.10.1
# TYPE=iso9660 LABEL=Ubuntu-Kylin\ 19.10
# 
# 
# 
#   16.3.57 probe
# 
# Command: probe [--set var] --driver|--partmap|--fs|--fs-uuid|--label device
# 
#     Retrieve device information. If option --set is given, assign result to variable var, otherwise print information on the screen.  


# 基于 https://github.com/aguslr/multibootusb 进行工作，仅仅需要其repo的部分文件，故

# 仅仅checkout https://github.com/aguslr/multibootusb 的部分文件：

#https://stackoverflow.com/questions/18857570/git-pull-without-checkout
#https://blog.csdn.net/zero_person_xianzi/article/details/87780019
#https://stackoverflow.com/questions/600079/how-do-i-clone-a-subdirectory-only-of-a-git-repository
 
#cd boot/grub
#git init
#git remote add origin https://github.com/aguslr/multibootusb.git
#git fetch 
#git config core.sparseCheckout true
#echo "mbusb.d/*"> .git/info/sparse-checkout
#echo "mbusb.cfg">> .git/info/sparse-checkout
#git checkout master

# 对于不能用这个方法的，则采用 （ddrescue / partclone.dd） 的方法。

# freebsd 用这个方法失败。
# win10安装不能用这个方法。
# debian安装不能用iso方法。

# Load mbusb configuration
if [ -e "$prefix/mbusb.cfg" ]; then
  source "$prefix/mbusb.cfg"
fi


function probe_os_type {

 if [ $# -ne 1 ]; then
   echo 'probe all of the os types which is cloned onto hd.'
   echo 'usage: probe_os_type device.'
   echo 'device is the whole device name, say (hd0), not part of it, say, (hd0,1).'
   sleep --verbose --interruptible 10 
   return 
 fi
 
 
    insmod part_msdos
	insmod ntfs
	
    insmod part_gpt
	insmod ext2
    insmod iso9660
	insmod regexp
    insmod loopback
    insmod chain


unset SYSRCD_root
unset SYSRCD_label

unset Debian_root
unset Debian_label

unset d_live_root
unset d_live_label

unset CentOS_root
unset CentOS_label

unset ARCH_root
unset ARCH_label

unset Gentoo_root
unset Gentoo_label

unset Kubuntu_root
unset Kubuntu_label

unset Deepin_root
unset Deepin_label

unset Ubuntu_Kylin_root
unset Ubuntu_Kylin_label

unset device




if [ $1 = '*' ]; then
  device=(*)
else
  device=($1,*) 
fi


 for file in $device; do
        
        unset fs
        unset iso_label
        unset os_type
        
         
         set rootdev=$file
        
         probe --set fs --fs $rootdev
         if [ x"$fs" = x"iso9660"  ]; then
           probe --set iso_label --label $rootdev
         fi        

          
    #    这样写：  "$os_label"，防止空值或其中有空格等特殊字符引起的问题。
         regexp -s os_type '^(SYSRCD|Debian|d-live|CentOS|ARCH|Gentoo|Kubuntu|Deepin|Ubuntu-Kylin)' "$iso_label"
            
         if  [ "x$os_type" = "xSYSRCD" ]; then
            SYSRCD_root=$rootdev
            SYSRCD_label="$iso_label"
         elif [ "x$os_type" = "xDebian" ]; then
            Debian_root=$rootdev
            Debian_label="$iso_label"
         elif [ "x$os_type" = "xd-live" ]; then
            d_live_root=$rootdev
            d_live_label="$iso_label"   
         elif [ "x$os_type" = "xCentOS" ]; then
            CentOS_root=$rootdev
            CentOS_label="$iso_label"
         elif [ "x$os_type" = "xARCH" ]; then
            ARCH_root=$rootdev
            ARCH_label="$iso_label"
         elif [ "x$os_type" = "xGentoo" ]; then
            Gentoo_root=$rootdev
            Gentoo_label="$iso_label"
         elif [ "x$os_type" = "xKubuntu" ]; then
            Kubuntu_root=$rootdev
            Kubuntu_label="$iso_label"
         elif [ "x$os_type" = "xDeepin" ]; then
            Deepin_root=$rootdev
            Deepin_label="$iso_label"
         elif [ "x$os_type" = "xUbuntu-Kylin" ]; then
            Ubuntu_Kylin_root=$rootdev
            Ubuntu_Kylin_label="$iso_label"
         fi

        
done

}



# $ sudo blkid -o export | awk '/LABEL=/ { if ( a ) print a, $0 }  /TYPE=iso9660/ {a=$0 } '
# TYPE=iso9660 LABEL=SYSRCD603
# TYPE=iso9660 LABEL=Debian\ 10.1.0\ amd64\ 1
# TYPE=iso9660 LABEL=CentOS-8-BaseOS-x86_64
# TYPE=iso9660 LABEL=ARCH_201910
# TYPE=iso9660 LABEL=Gentoo-amd64-hardened-nomultilib
# TYPE=iso9660 LABEL=Kubuntu\ 19.10\ amd64
# TYPE=iso9660 LABEL=Deepin\ 15.10.1
# TYPE=iso9660 LABEL=Ubuntu-Kylin\ 19.10





#sudo partclone.dd -d -s systemrescuecd-6.0.3.iso -o /dev/sdc3
# 这种方法具有通用性，如果基于 loopback 的方法失败，则用这个。

menuentry "SystemRescueCD（ddrescue / partclone.dd）" {

  

# 保留原始变量，以便后续还原：
set origroot=$root
 
# use the first found one: 
probe_os_type '*'
        
if  [ -n "$SYSRCD_root" ]; then
    
    set root=$SYSRCD_root
      
	#        https://www.gnu.org/software/grub/manual/grub/grub.html#export
	#	16.3.26 export

	#	Command: export envvar

	#	    Export the environment variable envvar. Exported variables are visible to subsidiary configuration files loaded using configfile. 

# 	似乎不应该 export ：
#     export root    
    configfile /boot/grub/grubsrcd.cfg  
    
    # 还原变量设定，菜单中其他的条目才能使用相关的默认配置文件：
    set root=$origroot          
            
 else
 	echo 'Failed to boot.'
	echo 'Press ESC to retrun.'    
	sleep --verbose --interruptible 10           
    
fi

}


#sudo partclone.dd -d -s debian-10.1.0-amd64-DVD-1.iso -o /dev/sdc4
menuentry 'Install debian amd64（ddrescue / partclone.dd）' {


	# 使用通配符展开，需要加载如下模块：
	#   https://stackoverflow.com/questions/42220111/filename-wildcard-expansion-in-grub-scripting
# 	insmod regexp

   # 这样使用，不使用系统原来的root变量，便于判断：
   
   # 基于 --hint 参数，会优先寻找相应设备，但是，如果 --hint的设备没有相关匹配，而其他设备有，
   # 则 会 将 rootdev 设为 其他设备 的值。因此，不是我所需要的结果。
   #search --set rootdev --label 'Debian 10.1.0 amd64 1' --no-floppy --hint hd0,
   

    # 从下面的文件的存在来判断 Debian 的位置：
    # 从那个盘启动，该盘为 hd0；
    # 如果该盘为usb，则进行搜索(目前不知道如何判断为usb盘)。
    # 但是，根据自己的实验结果，只有将系统dd 到 usb硬盘的主分区才是可行的。
    # 故在制作时，不要在 系统硬盘上 dd 这个。


# 保留原始变量，以便后续还原：
set origroot=$root
set origprefix=$prefix
set origcmdpath=$cmdpath

# 不能通过下的参数的设定来改变相应的路径的，这些是编译时确定的：

# https://www.gnu.org/software/grub/manual/grub/grub.html#grub_005fcpu

# 15.1.15 grub_cpu
# 
# In normal mode (see normal), GRUB sets the ‘grub_cpu’ variable to the CPU type for which GRUB was built (e.g. ‘i386’ or ‘powerpc’).
# 
# Next: icondir, Previous: grub_cpu, Up: Special environment variables   [Contents][Index]
# 15.1.16 grub_platform
# 
# In normal mode (see normal), GRUB sets the ‘grub_platform’ variable to the platform for which GRUB was built (e.g. ‘pc’ or ‘efi’). 


# 从 usb 启动的成功率最高，所以只将iso dd 到 usb 上面，然后
# 搜索所有的盘，即可：
probe_os_type '*'
        
if  [ -n "$Debian_root" ]; then
    

# 下面的方法，在有多个可能的结果存在时，比如 Debian live 和 Debian ，这两个的配置方法是相同的，即下面的命令都是满足的：
#search --file --set=root /.disk/info


# 此时，可能会造成混乱，除非 repack iso，仍然不易用比较简单的方法获得和 刻盘完全相同的安装效果。

    set root=$Debian_root

    set prefix=($root)/boot/grub
    set cmdpath=($root)/EFI/boot
    

#     基于修改 iso 上的那个最初调用的 grub.cfg 的方法，确保所有的配置文件被正确调用，
# 方法如下：
#  将 iso 上的 /EFI/debian/grub.cfg 修改如下：

# 进一步的方法，可以使用 pycdlib 来进行修改iso的操作。


#search --file --set=root /.disk/info
# search --label --set=root 'Debian 10.1.0 amd64 1'
# set prefix=($root)/boot/grub
# source $prefix/x86_64-efi/grub.cfg

#     这样的话，就可以用下面的方法，得到正确的 splash，字体 ，等相关设定，获得和刻盘，及将iso dd到整个usb的同样效果：
# 但是，这样也必须使用usb的某个分区，dd 到硬盘上仍然失败。
    chainloader $cmdpath/grubx64.efi
    # 下面这个命令运行后，就进入了 chainloader 的环境，下面的变量还原操作暂时不会执行：
    boot
    
    # 变量还原，基于 chainloader 的方法，如果启动失败，或者不打算实际安装，则 回到 grub命令行后，
    # 就会接着运行下面的命令，进行变量还原。
    # 然后，再运行命令 exit，就可以回到chainloader 之前的环境。
    
    set root=$origroot
    set prefix=$origprefix
    set cmdpath=$origcmdpath
    
 else
 	echo 'Failed to boot.'
	echo 'Press ESC to retrun.'    
	sleep --verbose --interruptible 10           
        
fi



}




# archlinux， 采用这里的方法并没有成功启动。
#https://wiki.archlinux.org/index.php/Multiboot_USB_drive#Arch_Linux


# 基于 硬盘 clone的方法和 基于 loopback的方法，都需要修改相应的 配置文件，
# 所以不能直接使用 configfile 命令来引导。

# 其原因在于 相应的 grub.cfg 中的某些参数写法和标准的 grub 不兼容。
# 考虑到基于硬盘clone的方法稳定性更好，这里使用此法：

#menuentry 'archlinux（ddrescue / partclone.dd）' {
#     
## (hd0,*)/loader/entries
## 会被识别成： (hd0,gpt7,msdos2)
## 这样的识别应该是 iso uefi 启动的规范。
## 当加载了相应的模块时，精细文件结构就出现了。

#    insmod part_msdos
#    insmod ntfs
#	insmod part_gpt
#	insmod ext2
#    insmod iso9660
#	insmod regexp
#    insmod loopback
#        
#    insmod chain



## 保留原始变量，以便后续还原：
#set origroot=$root


## 因为从 usb 启动的成功率最高，所以只探测 usb 上面的 iso 情况：
## 当从 usb 启动时，该盘为 hd0.  
#probe_os_type 'hd0'
#        
#if  [ -n "$ARCH_root" ]; then
#    
#  set root=$ARCH_root
#    
##   ref：/loader/entries/archiso-x86_64.conf
#  set archisolabel=$ARCH_label
#  
#  linux   /arch/boot/x86_64/vmlinuz archisobasedir=arch archisolabel=$archisolabel
#  initrd  /arch/boot/intel_ucode.img
#  initrd  /arch/boot/amd_ucode.img
#  initrd  /arch/boot/x86_64/archiso.img
#    
#    
#    
#  # 还原变量设定，菜单中其他的条目才能使用相关的默认配置文件：
#  set root=$origroot          
#            
#else
#  echo 'Failed to boot.'
#  echo 'Press ESC to retrun.'    
#  sleep --verbose --interruptible 10           
#    
#fi

# 
#}


#https://www.gnu.org/software/grub/manual/grub/grub.html#chainloader

#16.3.10 chainloader

#Command: chainloader [--force] file

#    Load file as a chain-loader. Like any other file loaded by the filesystem code, it can use the blocklist notation (see Block list syntax) to grab the first sector of the current partition with ‘+1’. If you specify the option --force, then load file forcibly, whether it has a correct signature or not. This is required when you want to load a defective boot loader, such as SCO UnixWare 7.1. 







