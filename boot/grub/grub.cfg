# Some pre-loaded modules：
    insmod part_msdos
    insmod ntfs
    insmod part_gpt
    insmod ext2
    insmod iso9660
    insmod regexp
    insmod loopback
    insmod chain
    insmod gzio

# Add the following for using by FreeBSD. 
# I'm not sure whether these modules are really needed or not, so loaded them just in case:
    insmod ufs2
    insmod zfs
    insmod bsd


# 采用新的命名规范：
# absolute directory name:
# 含设备名的：
# x_abs_dirname=$x_root$x_dirname
# x_abs_name=$x_root$x_name=$x_root$x_dirname$x_basename
# 不含设备名的： 
# x_name=$x_dirname$x_basename
# x_dirname
# x_basename


default='Ubuntu'

# Save the original root's value, so we can restore it later easilly：
set origroot=$root

for loader in (*)/boot/vmlinuz-*-amd64            \
              (*)/boot/vmlinuz                    \
              (*)/boot/vmlinuz-linux              \
              (*)/boot/vmlinuz-*-x86_64           \
              (*)/ROOT/*                          ; do
  
  # Only do the regexp test on the glob expanded strings to ensure that the corresponding file / directory is found,
  # and don'\''t test on the file / directory itself.
  # Essentially speaking, this is only do a string test with regexp.  It shouldn'\''t have trouble for all 
  # filesystems which grub found.
  # If the regexp module is loaded and the wild expansion is done correctly，the following
  # is enough to ensure that the corresponding device is found:
  if regexp '^\([^*]+\)' "$loader"; then
    regexp -s 1:loader_root -s 2:loader_dirname -s 3:loader_basename '^(\(.*\))(/.*/)([^/]+)$' "$loader"

    if regexp '^/boot/' $loader_dirname; then  
      if regexp 'vmlinuz-.*-amd64$' "$loader"; then
        menuentry "Debian GNU/Linux on $loader_root" "$loader_root" "$loader_dirname$loader_basename" --class linux --id Debian {
          # both the following regexp can be used to match the device name：
          # 
          # '^(\(.*\))'
          # '^\((.*)\)' 

          # but the first includes () in the result, while the latter not.
          # In the former case, when invoking the var，shouldn't use () ,
          # the exception is that the var's name is root, in this case, the 
          # () will be stripped automatically.  
          # so ($root) is correct。while ($var) is wrong for the former case. 
  
          set root=$2
          set vmlinuz_name=$3
          probe --set root_uuid --fs-uuid $root
          regexp -s initrd_name '^(.*)$' /boot/initrd.img-*-amd64    
    
          linux  $vmlinuz_name root=UUID=$root_uuid ro  
          initrd  $initrd_name
          # 还原变量设定，菜单中其他的条目才能使用相关的默认配置文件：
          set root=$origroot

          #https://www.gnu.org/software/grub/manual/grub/grub.html#boot
          #16.3.8 boot
          #Command: boot
          # Boot the OS or chain-loader which has been loaded. 
          # Only necessary if running the fully interactive command-line (it is implicit at the end of a menu entry). 
        }

      elif regexp 'vmlinuz$' "$loader"; then
        menuentry "Ubuntu on $loader_root" "$loader_root" "$loader_dirname$loader_basename" --class linux --id Ubuntu {
          set root=$2
          set vmlinuz_name=$3
          probe --set root_uuid --fs-uuid $root
          regexp -s initrd_name '^(.*)$' /boot/initrd.img   
    
          linux  $vmlinuz_name root=UUID=$root_uuid ro  
          initrd  $initrd_name
          set root=$origroot     
        }
      elif regexp 'vmlinuz-linux$' "$loader"; then
        menuentry "Arch Linux on $loader_root" "$loader_root" "$loader_dirname$loader_basename" --class linux --id Arch {
          set root=$2
          set vmlinuz_name=$3
          probe --set root_uuid --fs-uuid $root
          regexp -s initrd_name '^(.*)$' /boot/initramfs-linux.img     
    
          linux  $vmlinuz_name root=UUID=$root_uuid ro  
          initrd  $initrd_name
          set root=$origroot    
        }
      elif regexp 'vmlinuz-.*-x86_64$' "$loader"; then
        menuentry "Manjaro Linux on $loader_root" "$loader_root" "$loader_dirname$loader_basename" --class linux --id Manjaro {
          set root=$2
          set vmlinuz_name=$3
          probe --set root_uuid --fs-uuid $root
          regexp -s initrd_name '^(.*)$' /boot/initramfs-*-x86_64-fallback.img     
    
          linux  $vmlinuz_name root=UUID=$root_uuid ro  
          initrd  $initrd_name
          set root=$origroot    
        }
      fi

    # Dealing with BSD based operating systems separately:
    # When using zfs filesystem, be sure not to search/test under the directory /@/,
    # in this case, grub2 will failed and 
    # finally, the menuentry will not be constructed.
    # it seems the grub2 cannot work smoothly with zfs filesystem.
    elif regexp '^/ROOT/' $loader_dirname; then  
      loader_name=$loader_dirname$loader_basename/@/boot/loader.efi    
      if regexp '^/ROOT/default/' "$loader_name"; then 
        menuentry "FreeBSD on $loader_root" "$loader_root" "$loader_name" --class unix --id FreeBSD {
          loader_root="$2"
          loader_name="$3"  
          set root=$loader_root
          chainloader $loader_name 
          boot
          set root=$origroot
        } 
      elif regexp '^/ROOT/initial/' "$loader_name"; then 
        menuentry "GhostBSD on $loader_root" "$loader_root" "$loader_name" --class unix --id GhostBSD {
          loader_root="$2"
          loader_name="$3"  
          set root=$loader_root
          chainloader $loader_name 
          boot
          set root=$origroot
        }       
      fi
    fi
  fi
done
 
## Dealing with BSD based operating systems separately:
## When using zfs filesystem, be sure not to search/test under the directory /@/,
## in this case, grub2 will failed and 
## finally, the menuentry will not be constructed.
## it seems the grub2 cannot work smoothly with zfs filesystem.
#for loader in (*)/ROOT/*; do
#  if regexp '^\([^*]+\)' "$loader"; then
#    regexp -s 1:loader_root -s 2:loader_dirname -s 3:loader_basename '^(\(.*\))(/.*/)([^/]+)$' "$loader"
#    if regexp '^/ROOT/' $loader_dirname; then  
#      loader_name=$loader_dirname$loader_basename/@/boot/loader.efi    
#      if regexp '^/ROOT/default/' "$loader_name"; then 
#        menuentry "FreeBSD on $loader_root" "$loader_root" "$loader_name" {
#          loader_root="$2"
#          loader_name="$3"  
#          set root=$loader_root
#          chainloader $loader_name 
#          boot
#          set root=$origroot
#        } 
#      elif regexp '^/ROOT/initial/' "$loader_name"; then 
#        menuentry "GhostBSD on $loader_root" "$loader_root" "$loader_name" {
#          loader_root="$2"
#          loader_name="$3"  
#          set root=$loader_root
#          chainloader $loader_name 
#          boot
#          set root=$origroot
#        }       
#      fi
#    fi
#  fi
#done




### BEGIN /usr/local/etc/grub.d/41_custom ###
if [ -f  ${config_directory}/custom.cfg ]; then
  source ${config_directory}/custom.cfg
elif [ -z "${config_directory}" -a -f  $prefix/custom.cfg ]; then
  source $prefix/custom.cfg;
fi
### END /usr/local/etc/grub.d/41_custom ###






