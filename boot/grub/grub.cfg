
# 考虑到 boot loader 的重要性，尽量使用 grub的稳定版本。

# 从 git 中check 最新的稳定版本进行使用。

# 预先加载一些模块，以备使用：
    insmod part_msdos
    insmod ntfs
	
    insmod part_gpt
    insmod ext2
    insmod iso9660
 
# add the following for using by FreeBSD:   
# In fact, I don't know whether these are necessary or not:
    insmod ufs2
    insmod zfs
    insmod bsd
   
    insmod regexp
    insmod loopback
        
    insmod chain

    insmod gzio

#
# DO NOT EDIT THIS FILE
#
# It is automatically generated by grub-mkconfig using templates
# from /usr/local/etc/grub.d and settings from /usr/local/etc/default/grub
#

### BEGIN /usr/local/etc/grub.d/00_header ###
if [ -s $prefix/grubenv ]; then
  load_env
fi
if [ "${next_entry}" ] ; then
   set default="${next_entry}"
   set next_entry=
   save_env next_entry
   set boot_once=true
else
   set default="0"
fi

if [ x"${feature_menuentry_id}" = xy ]; then
  menuentry_id_option="--id"
else
  menuentry_id_option=""
fi

export menuentry_id_option

if [ "${prev_saved_entry}" ]; then
  set saved_entry="${prev_saved_entry}"
  save_env saved_entry
  set prev_saved_entry=
  save_env prev_saved_entry
  set boot_once=true
fi

function savedefault {
  if [ -z "${boot_once}" ]; then
    saved_entry="${chosen}"
    save_env saved_entry
  fi
}

function load_video {
  if [ x$feature_all_video_module = xy ]; then
    insmod all_video
  else
    insmod efi_gop
    insmod efi_uga
    insmod ieee1275_fb
    insmod vbe
    insmod vga
    insmod video_bochs
    insmod video_cirrus
  fi
}

if [ -s $prefix/fonts/unicode.pf2 ]; then
  font=$prefix/fonts/unicode.pf2
fi

#font=$prefix/fonts/WenQuanYiMicroHeiMono24px.pf2
# font=$prefix/fonts/DejaVuSansMonoYaHeiNF.ttf

if loadfont $font ; then
  set gfxmode=auto
  load_video
  insmod gfxterm
  set locale_dir=$prefix/locale
  set lang=en_US
  insmod gettext
fi
terminal_output gfxterm


#set gfxterm_font=WenQuanYiMicroHeiMono24px
#loadfont WenQuanYiMicroHeiMono24px



# failed to chang font with following steps:

#/hybrid-fonts/Hybrid-fonts.git/DejaVuSansMono YaHei NF/DejaVuSansMono YaHei NF.ttf

#root@debian-01:/media/werner/2cfeab3f-8ac3-4471-b385-72da26c212d0# grub-mkfont --output=DejaVuSansMono-YaHei-NF.pf2 --size=24 boot/grub/fonts/hybrid-fonts/Hybrid-fonts.git/DejaVuSansMono\ YaHei\ NF/DejaVuSansMono\ YaHei\ NF.ttf

#set font=$prefix/fonts/DejaVuSansMono-YaHei-NF.pf2
#set gfxterm_font=$prefix/fonts/DejaVuSansMono-YaHei-NF.pf2



if [ x$feature_timeout_style = xy ] ; then
  set timeout_style=menu
  set timeout=5
# Fallback normal timeout code in case the timeout_style feature is
# unavailable.
else
  set timeout=5
fi
### END /usr/local/etc/grub.d/00_header ###

### BEGIN /usr/local/etc/grub.d/10_linux ###


menuentry 'Debian GNU/Linux' {
	load_video
	set gfxpayload=keep

	#set root='hd0,4'
     
     # 如何根据特定的文件来判断是那个操作系统。
     # 就目前所用的 debian 和 Ubuntu 来说，可以使用下面的方法简单区分：
   
     # debian 的 boot 目录有如下文件，且版本号唯一：
     #  /boot/vmlinuz-*-amd64
     #  /boot/initrd.img-*-amd64   
     
     # Ubuntu 的 boot 目录有如下链接，指向实际所用的文件：
     # /boot/vmlinuz
     # /boot/initrd.img


# 保留原始变量，以便后续还原：
set origroot=$root

     for file in (*)/boot/vmlinuz-*-amd64; do
         if test -f $file; then 
          #regexp -s 1:boot_root -s 2:filepath '^(\(.*\))(/.*)$' "$file" 
          # 下面的写法都可以达到目的：
          # '^(\(.*4\))'
          # '^\((.*4)\)' 

          # 需要注意，在第一种写法里，包括了 () 在结果中，
          # 因此，使用时不能再加 () 了，比如 ($boot_root) 就是不对的。
          # 但是 ，第二中匹配的结果就没有这个问题。   
            regexp -s boot_root '^(\(.*\))' $file
	    probe --set root_uuid --fs-uuid $boot_root
	    search --no-floppy --fs-uuid --set=root $root_uuid
    
	    regexp -s vmlinuz_name '^(.*)$' /boot/vmlinuz-*-amd64
	    regexp -s initrd_name '^(.*)$' /boot/initrd.img-*-amd64    
    
	    linux  $vmlinuz_name root=UUID=$root_uuid ro  
	    initrd  $initrd_name
            
            # 找到第一个符合条件的启动项，就退出 for loop: 
            break
        fi   
     done 
  


# 还原变量设定，菜单中其他的条目才能使用相关的默认配置文件：
set root=$origroot


if [ -z "$boot_root" ]; then
	echo 'Failed to boot.'
	echo 'Press ESC to retrun.'    
	sleep --verbose --interruptible 10
fi


# 在非交互模式，隐含的最后一个命令就是 boot：

#https://www.gnu.org/software/grub/manual/grub/grub.html#boot
#16.3.8 boot

#Command: boot

#    Boot the OS or chain-loader which has been loaded. Only necessary if running the fully interactive command-line (it is implicit at the end of a menu entry). 


  
}


menuentry 'Arch Linux' {

# 保留原始变量，以便后续还原：
set origroot=$root

     for file in (*)/boot/initramfs-linux.img; do
         if test -f $file; then 
          #regexp -s 1:boot_root -s 2:filepath '^(\(.*\))(/.*)$' "$file" 
          # 下面的写法都可以达到目的：
          # '^(\(.*4\))'
          # '^\((.*4)\)' 

          # 需要注意，在第一种写法里，包括了 () 在结果中，
          # 因此，使用时不能再加 () 了，比如 ($boot_root) 就是不对的。
          # 但是 ，第二中匹配的结果就没有这个问题。   
            regexp -s boot_root '^(\(.*\))' $file
            probe --set root_uuid --fs-uuid $boot_root
	    search --no-floppy --fs-uuid --set=root $root_uuid
    
	    regexp -s vmlinuz_name '^(.*)$' /boot/vmlinuz-linux
	    regexp -s initrd_name '^(.*)$' /boot/initramfs-linux.img   
    
	    linux  $vmlinuz_name root=UUID=$root_uuid ro  
	    initrd $initrd_name
            
            # 找到第一个符合条件的启动项，就退出 for loop: 
            break
        fi   
     done 
# 还原变量设定，菜单中其他的条目才能使用相关的默认配置文件：
set root=$origroot
if [ -z "$boot_root" ]; then
	echo 'Failed to boot.'
	echo 'Press ESC to retrun.'    
	sleep --verbose --interruptible 10
fi
}






#FreeBSD:

for loader in (*)/ROOT/default/@/boot/loader.efi; do
  if [ -e "$loader" ]; then
    regexp -s 1:loader_root -s 2:loader_dirname -s 3:loader_basename '^(\(.*\))(/.*/)([^/]+)$' "$loader"
    menuentry "FreeBSD -> $loader_root" "$loader_root" "$loader_dirname$loader_basename" {
    
      # 采用新的命名规范：
      # absolute directory name:
      # 含设备名的：
      # x_abs_dirname=$x_root$x_dirname
      # x_abs_name=$x_root$x_name=$x_root$x_dirname$x_basename
      # 不含设备名的： 
      # x_name=$x_dirname$x_basename
      # x_dirname
      # x_basename

      loader_root="$2"
      loader_name="$3"  
      set root=$loader_root
      chainloader $loader_name 

    }
  fi
done






menuentry 'Ubuntu' {
        
       load_video
        set gfxpayload=keep
           
        #set root='hd0,3'

# 保留原始变量，以便后续还原：
set origroot=$root

       for file in (*)/boot/vmlinuz; do
          if [ -f $file ]; then
            regexp -s boot_root '^\((.*)\)' $file
            probe --set root_uuid --fs-uuid $boot_root
            search --no-floppy --fs-uuid --set=root $root_uuid

            regexp -s vmlinuz_name '^(.*)$' /boot/vmlinuz
            regexp -s initrd_name '^(.*)$' /boot/initrd.img

            linux  $vmlinuz_name root=UUID=$root_uuid ro 
            initrd  $initrd_name
            break
     
         fi
       done


# 还原变量设定，菜单中其他的条目才能使用相关的默认配置文件：
set root=$origroot


if [ -z "$boot_root" ]; then
	echo 'Failed to boot.'
	echo 'Press ESC to retrun.'    
	sleep --verbose --interruptible 10
fi
   


}


### END /usr/local/etc/grub.d/10_linux ###

### BEGIN /usr/local/etc/grub.d/20_linux_xen ###

### END /usr/local/etc/grub.d/20_linux_xen ###

### BEGIN /usr/local/etc/grub.d/30_os-prober ###
### END /usr/local/etc/grub.d/30_os-prober ###

### BEGIN /usr/local/etc/grub.d/40_custom ###
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.
### END /usr/local/etc/grub.d/40_custom ###

### BEGIN /usr/local/etc/grub.d/41_custom ###
if [ -f  ${config_directory}/custom.cfg ]; then
  source ${config_directory}/custom.cfg
elif [ -z "${config_directory}" -a -f  $prefix/custom.cfg ]; then
  source $prefix/custom.cfg;
fi
### END /usr/local/etc/grub.d/41_custom ###

