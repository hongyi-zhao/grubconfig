#根据实际的测试，下面方法是可以的，实现了从硬盘安装debian：
# 1- 在使用这个方法的时候，不能在安装中挂载安装镜像 iso 所在的分区。
# 安装盘iso镜像放到了hd0的最后一个分区上。注意这个不能是链接。
#
# 2- 考虑到使用的方便性，在这个文件中直接挂载相应的 /hd-media/ 下面的文件，可以是链接位置。
#  比如我这里所用的 current 文件夹实际是一个链接。
#[按照目前的rdmirror.sh中的实现方法，current 文件夹已经不再是链接了]
# 
#
# 3- 将这个文件copy到 /boot/grub/ ，就可以被 /boot/grub/grub.cfg 加载了。
# 4- for debian oldstable, i.e., squeeze, the ext4 filesystem isn't recongnized by 
# it's hd-media boot files.  So use the last part of hd0 formatted to ext3 to store the dvd iso files.
# based on the above description, all of the dvd iso's used for installation, are now stored in the last part of hd0.
# 5- 但是，进一步的尝试发现，jessie版本的iso在ext3上不能被找到。而且squeeze确实不好用。故将hd0最后一个小分区格式化为ext4，
# 用来存放相应的iso文件。
# 6- 目前的 debian multiarch似乎也是在实验阶段，常常遇到包安装的冲突问题。看使用单纯的i386版本如何。
# 进一步的分析表明，实际上我所遇到的libssl-dev, python-dev 安装时由于包冲突而无法进行的问题，实际上是由于我使用了部分的包仓库。
# 按照后来的分析，加入了stable版本的库的各个部分。这些问题解决了。
# 
# [上面所说的libssl-dev, python-dev 安装时由于包冲突而无法进行的问题，实际上是由于我混乱使用包仓库所导致的。]
# ref: werner@debian:~/software/LocalRepo/当前的repo设定$ ls \[used-for-now\]关于应该如何设定软件库的再思考
# [used-for-now]关于应该如何设定软件库的再思考
#
# 7- desktop=gnome 是用来选择默认安装的桌面环境是gnome。
# 8- 实际上，这个配置文件的编写是从 iso 镜像以及本地debian系统的中的下面这个文件：
# /boot/grub/grub.cfg
# 中的相关写法，参考修改而来。

# instructions for installation:
#
# 9- ref: 
# https://www.debian.org/devel/debian-installer/
#
#
# Installation Guide: version for current release
# detailed installation instructions
#
# https://www.debian.org/releases/stable/installmanual
# https://www.debian.org/releases/stable/amd64/
#
# latest version (Subversion)
# http://d-i.debian.org/manual/
# http://d-i.debian.org/manual/en.amd64/
# http://d-i.debian.org/manual/zh_CN.amd64/

# expecially here, can find some hints for my case:
# http://d-i.debian.org/manual/en.amd64/ch05s01.html#boot-initrd

# 10- When use multiple Debian install os images under the top level of the partition,
# first change the surffix ( let the suffix not iso ) or put the iso under some sub-dir which is not used for installation. 

# Say, for install testing ( it seems this step for testing installation is not needed ):

# Firstly, rename the debian-8.7.1-amd64-DVD-1.iso to debian-8.7.1-amd64-DVD-1.iso.not-scan 

# for install stable:

# Firstly, rename the debian-testing-amd64-DVD-1.iso to debian-testing-amd64-DVD-1.iso.not-scan 



# 11- install the latest grub:

# 安装最新版本的grub2：
# https://ftp.gnu.org/gnu/grub/
# sudo apt-get build-dep grub2
# ./configure 
# make -j24
# sudo make install
# sudo grub-install /dev/sda
# sudo update-grub


# 12-
# 使用regexp模块：
# https://www.rmprepusb.com/tutorials/grub2_tutorial137
# 一些摘录：
# Scripting
# Loosely follows bash shell
# Useful functions and notes regular expressions

# function pathname { regexp -s 2:"$2" '^(\(.*\))?(/.*)$' "$1"; } # /_ISO/ubuntu 64.iso
# function devname { regexp -s "$2" '^(\(.*\)).*$' "$1"; } # (hd0,msdos2)
# function pathonly { regexp -s 2:"$2" '^(\(.*\))?(.*/)*' "$1"; } # /_ISO/
# function getext { regexp -s 3:"$2" '^(.*/)*(.*)\.(.*)$' "$1"; } # iso
# function getfname { regexp -s 2:"$2" '(.*)/+(.*)' "$1"; } # ubuntu 64.iso
# function gethdnum { regexp -s 2:"$2" '^(.*)hd(.*),' "$1"; } # 0
# function getdev { regexp -s 2:"$2" '^(.*)\((.*),' "$1"; } # hd0


# usage where $file = (hd0,msdos1)/_ISO/DIR/some file name with spaces.iso
# # set isopath to the fullpath without device name

# pathname "$file" isopath # make sure double-quotes around $file - this sets the isopath variable to /_ISO/DIR/some file name with spaces.iso

# 2: = get second match value, 3: = 3rd matched value
# ^ = start at beginning
# $ = up to end of line

# If looking for ( or ) then must precede with \

# (\(.*\))? = look for ( then anything then ) ? is zero or more of preceding match which is enclosed in ( )
# (/.*)$ = look for / followed by any chars up to end of line

# (.+/)* = look for 1 or more chars up to / any number of times
# (*+)\. = look for 0 or more chars followed by .
# (.+)$ = look for all chars till end of line


# e.g. regexp -s 2:"$2" '^(.*)\((.*),'

# ^ = start at beginning of line, look for any number of chars (.*), look for open parenthesis (, look for any number chars (.*), look for comma , - return 2nd match in parentheses as $2.


# testing regexp from the grub2 command line

# unset fred ; regexp -s 2:"fred" 'test regexp here' "$file" ; echo $fred
# # if filename does not contain ubuntu then abort
# if ! regexp '(.*)[uU][bB][uU][nN][tT][uU]' "$myfname" ; then continue ; fi
 

# https://lists.gnu.org/archive/html/grub-devel/2016-09/msg00018.html
# 下面这个文件中也有许多高级的用法：
# /media/werner/7ac9245c-3441-4dc2-a6e8-2267bea3c29f/grub/grub.git/docs/autoiso.cfg


# 13- probe
#https://www.gnu.org/software/grub/manual/grub/grub.html

#https://askubuntu.com/questions/228031/how-do-you-get-a-uuid-from-a-a-device-on-the-grub2-prompt

#Programmatically, this can be queried with the probe command, e.g.:

#probe --fs-uuid (hd0,gpt6)

#The result can also be assigned to a variable with --set:

#probe --set devuuid --fs-uuid (hd0,gpt6)
#echo $devuuid


#http://www.jinbuguo.com/linux/grub.cfg.html
#probe [--set var] --driver|--partmap|--fs|--fs-uuid|--label device
#    提取"device"设备的特定信息。如果使用了 --set 选项，则表示将提取的结果保存在"var"变量中，否则将提取的结果直接显示出来。



# 14- source / configfile
#configfile file

#    将"file"作为配置文件加载。如果"file"中定义了菜单项，那么立即显示一个包含它们的菜单。

#    [注意]"file"文件对环境变量所做的任何变更都将在从此文件返回后失效。

#source file

#    直接将"file"文件的内容插入到当前位置。与"configfile"不同，此命令既不切换执行环境，也不会显示一个新的菜单。



# 15-

#https://www.gnu.org/software/grub/manual/grub/grub.html#cmp

#16.3.65 search

#Command: search [--file|--label|--fs-uuid] [--set [var]] [--no-floppy] name

#    Search devices by file (-f, --file), filesystem label (-l, --label), or filesystem UUID (-u, --fs-uuid).

#    If the --set option is used, the first device found is set as the value of environment variable var. The default variable is ‘root’.

#    The --no-floppy option prevents searching floppy devices, which can be slow.

#    The ‘search.file’, ‘search.fs_label’, and ‘search.fs_uuid’ commands are aliases for ‘search --file’, ‘search --label’, and ‘search --fs-uuid’ respectively. 

# 关于 --hint

#grub.git$ grep -r -- '--hint' *

#可以观察源码发现相关的说明：
#grub.git$ cat grub-core/commands/search_wrap.c


#https://unix.stackexchange.com/questions/115555/what-does-the-hint-option-in-grub2s-search-command-do/126601#126601

#This is not described in the GRUB Manual but there is documentation to be found in GRUB itself (search --help on the GRUB shell):

#--hint
#    First try the device HINT.
#    If HINT ends in comma, also try subpartitions

#--hint-ieee1275
#    First try the device HINT if currently running on IEEE1275.
#    If HINT ends in comma, also try subpartitions

#--hint-bios
#    First try the device HINT if currently running on BIOS.
#    If HINT ends in comma, also try subpartitions

#--hint-baremetal
#    First try the device HINT if direct hardware access is supported.
#    If HINT ends in comma, also try subpartitions

#--hint-efi
#    First try the device HINT if currently running on EFI.
#    If HINT ends in comma, also try subpartitions

#--hint-arc
#    First try the device HINT if currently running on ARC.
#    If HINT ends in comma, also try subpartitions


# 这里给出的 search --file 例子，

# 但是，整个方法不支持 通配符，因此，不如 for + regexp 的方法功能强大。 


#http://blog.sciencenet.cn/blog-2353794-881814.html
#http://www.jinbuguo.com/linux/grub.cfg.html

#启动某个引导文件：
#menuentry "启动 G4D"{
#search --file /grldr --set=root
#insmod ntldr
#ntldr /grldr
#}




#https://www.gnu.org/software/grub/manual/grub/grub.html#Multi_002dboot-manual-config
#https://www.gnu.org/software/grub/manual/grub/grub.html#Embedded-configuration

# 对于 debian的 硬盘安装方法，经常会失败，最可靠的方法就是将 iso 直接 dd到硬盘的方法。
# 这个方法有如下限制：
# 必须将iso dd到整个硬盘（usb或其他硬盘）或usb硬盘的主分区。
# 故采用gpt分区表，以便支持大硬盘和更多的主分区。

# 但是对于各种live iso，则采用 iso dd 的方法到整个硬盘或硬盘的某个主分区，都是可以的。
# 实际测试的情况也不是如此。各种live iso的情况也是很复杂的。最保险的方法就是把iso dd到整个硬盘。
# 但是这个方法需要有一个独立的备用硬盘。


# 原则上，能直接使用 iso 成功的，就不是有类dd的方法。

# 从那个盘启动，那个盘就是 hd0.


# 尝试grub2 efi，看能否解决目前的问题。


#sudo partclone.dd -d -s debian-10.1.0-amd64-DVD-1.iso -o /dev/sdc4
menuentry 'Installing debian stable amd64（partclone.dd）' {

	insmod part_msdos
	insmod part_gpt
	insmod ext2

# 使用通配符展开，需要加载如下模块：
#   https://stackoverflow.com/questions/42220111/filename-wildcard-expansion-in-grub-scripting
   insmod regexp
   # 这样使用，不使用系统原来的root变量，便于判断：
   
   # 基于 --hint 参数，会优先寻找相应设备，但是，如果 --hint的设备没有相关匹配，而其他设备有，
   # 则 会 将 rootdev 设为 其他设备 的值。因此，不是我所需要的结果。
   #search --set rootdev --label 'Debian 10.1.0 amd64 1' --no-floppy --hint hd0,
   

    # 从下面的文件的存在来判断 Debian 的位置：
    # 从那个盘启动，该盘为 hd0；
    # 如果该盘为usb，则进行搜索(目前不知道如何判断为usb盘)。
    # 但是，根据自己的实验结果，只有将系统dd 到 usb硬盘的主分区才是可行的。
    # 故在制作时，不要在 系统硬盘上 dd 这个。
   for file in (*)/dists/*/main/debian-installer/binary-amd64/Release; do
     if test -f "$file"; then
      regexp -s 1:rootdev -s 2:codename '^(\(.*\))/dists/([^/]+).*$' "$file"
      root=$rootdev
      configfile /boot/grub/grub.cfg
      break
     fi      
   done 
   
   if [ -z "$rootdev" ]; then
       echo 'Cannot found the cloned system for installation.'
   fi


  }


#sudo partclone.dd -d -s systemrescuecd-6.0.3.iso -o /dev/sdc3
# 这种方法具有通用性，如果基于 loopback 的方法失败，则用这个。

menuentry "SystemRescueCD（partclone.dd）" {

	insmod part_msdos
	insmod part_gpt
	insmod ext2
	insmod regexp
      
      for file in (hd0,*)/sysresccd; do
        if test -d "$file"; then
          regexp -s 1:rootdev -s 2:filepath '^(\(.*\))(/.*)$' "$file"
          set root=$rootdev     
          configfile /boot/grub/grubsrcd.cfg    
          break     
        fi
      done 
}




# 这种方法并不具有通用性，clonezilla， gparted 都没有用这种方法成功启动：
# 再次启动系统，这个方法又不行了。
#menuentry "SystemRescueCD（loopback）" {

#        insmod part_msdos
#	insmod part_gpt
#	insmod ext2
#	insmod regexp
#        insmod loopback
#    
#    # search 支持通配符，也需要 regexp 模块的预先加载：
#   # 基于 --hint 参数，会优先寻找相应设备，但是，如果 --hint的设备没有相关匹配，而其他设备有，
#   # 则 会 将 rootdev 设为 其他设备 的值。因此，不是我所需要的结果。
#    #search --set rootdev --file /sysadmin/systemrescuecd/systemrescuecd-*.iso --no-floppy --hint hd0,
#    
#    # 这种工具性的东西，每个启动盘上都安装，各自使用自己的，所以如下：
#    for file in (hd0,*)/sysadmin/systemrescuecd/systemrescuecd-*.iso; do
#      if test -f "$file"; then         
#        regexp -s 1:rootdev -s 2:filepath '^(\(.*\))(/.*)$' "$file"
#        isofile=$rootdev$filepath
#        loopback loop $isofile
#        set root=(loop)
#        configfile /boot/grub/grubsrcd.cfg       

#        
#        break 
#      fi 
#   done
#}



# 在 menu 中使用变量，还没有弄清楚。

#https://github.com/aguslr/multibootusb/blob/master/mbusb.d/debian.d/live9-generic.cfg

#for file in (*)/sysadmin/gparted/gparted-live-*-amd64.iso; do
#  if [ -e "$file" ]; then

#        insmod part_msdos
#	insmod part_gpt
#	insmod ext2
#	insmod regexp
#        insmod loopback

#    regexp -s 1:rootdev -s 2:filepath "^(\(.*\))(/.*)$" "$file"
#    submenu "$filepath (grub.cfg) ->" "$rootdev" "$file" {
#      iso_path="$3"
#      root=$rootdev
#      export iso_path
#      export root
##      search --set=root --file "$iso_path"
#      loopback loop "$iso_path"
#      root=(loop)
#      configfile /boot/grub/grub.cfg
#      loopback --delete loop
#    }
#  fi
#done


# 下面的方法虽然能启动，但是发现他们乱了。
# 启动gparted，却最后发现是进入了 clonezilla。
# 只有把他们单独 dd 到整个硬盘，才是最可靠的方法。
#menuentry "clonezilla（partclone.dd）" {

#	insmod part_msdos
#	insmod part_gpt
#	insmod ext2
#	insmod regexp
#      
#      for file in (hd0,*)/Clonezilla-Live-Version; do
#        if test -f "$file"; then
#          regexp -s 1:rootdev -s 2:filepath '^(\(.*\))(/.*)$' "$file"
#          set root=$rootdev     
#          configfile /boot/grub/grub.cfg    
#          break     
#        fi
#      done

#}


#menuentry "gparted（partclone.dd）" {

#	insmod part_msdos
#	insmod part_gpt
#	insmod ext2
#	insmod regexp
#      
#      for file in (hd0,*)/GParted-Live-Version; do
#        if test -f "$file"; then
#          regexp -s 1:rootdev -s 2:filepath '^(\(.*\))(/.*)$' "$file"
#          set root=$rootdev     
#          configfile /boot/grub/grub.cfg    
#          break     
#        fi
#      done

#}



# 下面的方法失败：

#menuentry "clonezilla（loopback）" {

#        insmod part_msdos
#	insmod part_gpt
#	insmod ext2
#	insmod regexp
#        insmod loopback
#    
#    # search 支持通配符，也需要 regexp 模块的预先加载：
#   # 基于 --hint 参数，会优先寻找相应设备，但是，如果 --hint的设备没有相关匹配，而其他设备有，
#   # 则 会 将 rootdev 设为 其他设备 的值。因此，不是我所需要的结果。
#    #search --set rootdev --file /sysadmin/systemrescuecd/systemrescuecd-*.iso --no-floppy --hint hd0,
#    
#    # 这种工具性的东西，每个启动盘上都安装，各自使用自己的，所以如下：
#    for file in (hd0,*)/sysadmin/clonezilla/clonezilla-live-*-amd64.iso; do
#      if test -f "$file"; then         
#        regexp -s 1:rootdev -s 2:filepath '^(\(.*\))(/.*)$' "$file"
#        isofile=$rootdev$filepath
#        loopback loop $isofile
#        set root=(loop)
#        configfile /boot/grub/grub.cfg       
#        loopback --delete loop
#        break 
#      fi 
#   done

#}



#menuentry "gparted（loopback）" {

#        insmod part_msdos
#	insmod part_gpt
#	insmod ext2
#	insmod regexp
#        insmod loopback
#    
#    # search 支持通配符，也需要 regexp 模块的预先加载：
#   # 基于 --hint 参数，会优先寻找相应设备，但是，如果 --hint的设备没有相关匹配，而其他设备有，
#   # 则 会 将 rootdev 设为 其他设备 的值。因此，不是我所需要的结果。
#    #search --set rootdev --file /sysadmin/systemrescuecd/systemrescuecd-*.iso --no-floppy --hint hd0,
#    
#    # 这种工具性的东西，每个启动盘上都安装，各自使用自己的，所以如下：
#    for file in (hd0,*)/sysadmin/gparted/gparted-live-*-amd64.iso; do
#      if test -f "$file"; then         
#        regexp -s 1:rootdev -s 2:filepath '^(\(.*\))(/.*)$' "$file"
#        isofile=$rootdev$filepath
#        loopback loop $isofile
#        root=(loop)
#        configfile /boot/grub/grub.cfg       
#        loopback --delete loop
#         
#        break 
#      fi 
#   done

#}







#menuentry "Running debian-cd current-live amd64 from hd-media" {
#	load_video
#	insmod gzio
#	insmod part_msdos
#	insmod part_gpt
#	insmod ext2
#	insmod regexp
#       insmod loopback
#       insmod iso9660

#    # 参考 debian-live-*-amd64-gnome.iso 中提供的 grub.cfg, 和下面的cfg 中的用法：
#    # /media/werner/7ac9245c-3441-4dc2-a6e8-2267bea3c29f/grub/grub.git/docs/autoiso.cfg
#    for file in (*)/debian-nonfree/cd-including-firmware/current-live/amd64/iso-hybrid/debian-live-*-amd64-gnome*.iso; do
#        if test -f "$file"; then
#          regexp -s 1:rootdev -s 2:isopath '^(\(.*\))(/.*)$' "$file"
#          isofile=$rootdev$isopath
#        fi
#    done
#   
#   # http://forums.debian.net/viewtopic.php?f=17&t=121092  

##  see the following for very good examples:   
##   http://www.jinbuguo.com/linux/grub.cfg.html

## the following is taken from above website:

##https://mirrors.ustc.edu.cn/debian-cd/current-live/amd64/iso-hybrid/
##也适用于'Kali LiveCD [root/toor]'( username=root hostname=kali ) https://cdimage.kali.org/current/
##if [ -f $prefix/linux/debian-live-gnome.iso ] ; then
##    menuentry 'Debian 10.1 GNOME LiveCD (NO SSH)' --unrestricted {
##        loopback loop0 $prefix/linux/debian-live-gnome.iso
##        linux  (loop0)/live/vmlinuz-4.19.0-6-amd64 boot=live findiso=/grub/linux/debian-live-gnome.iso   components locales=zh_CN.UTF-8
##        initrd (loop0)/live/initrd.img-4.19.0-6-amd64
##    }
##fi

#   if [ -n "$isofile" ]; then
#      # 下面这行用不用都可以：
#      # set root=$rootdev
#      loopback loop $isofile
#      regexp -s vmlinuzfile '^(.*)$' (loop)/live/vmlinuz-*-amd64
#      regexp -s initrdfile '^(.*)$' (loop)/live/initrd.img-*-amd64
#      linux  $vmlinuzfile boot=live components findiso=$isopath noeject
#      initrd $initrdfile 

#  fi
#}








