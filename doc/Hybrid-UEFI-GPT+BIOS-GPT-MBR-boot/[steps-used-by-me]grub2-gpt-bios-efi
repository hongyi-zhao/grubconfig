1-

首先用 ddrescue 、dd ， partclone.dd
 等工具将该盘分区表清空。

比如：

下面的这个可以保证足够吧 前两个分区清零：

$ sudo dd if=/dev/zero of=/dev/sdc bs=1M count=1000


然后，使用 gparted，gdisk等工具，建立如下的分区结构：


werner@debian-01:~$ sudo gdisk -l /dev/sdc
GPT fdisk (gdisk) version 1.0.3

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.
Disk /dev/sdc: 60063744 sectors, 28.6 GiB
Model: Ultra USB 3.0   
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): F665095B-CB40-476B-876B-27C48DAC61F1
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 60063710
Partitions will be aligned on 2048-sector boundaries
Total free space is 39374781 sectors (18.8 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048            6143   2.0 MiB     EF02  
   2            6144          210943   100.0 MiB   EF00  
   3          210944        20690943   9.8 GiB     8300 


2- 安装方法：


a-

首先要从bios中设定 efi的启动方法，然后，用 SYSRCD603 或任何支持 efi启动的live usb启动到grub2，
在 grub2 中使用 命令 
set root=hd1,3
prefix=($root)/grubconfig.git/boot/grub 
configfile $prefix/grub.cfg

的 方法进入 Debian 系统。 


下面的目录存在，则表面是efi方式启动：

ls /sys/firmware/efi/


b- 使用自己编译的grub的最新稳定版本。

ref：
/media/werner/e3e084db-7f7f-47cb-866b-743b7c5758ec1/sysadmin/grub/grub.git.sh


grub-install ... -v  观察其调用细节，发现是基于  grub-mkimage / efibootmgr工作的。





基于 grub-mkimage 的方法:

ref：
https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/uefi-grub2?lang=en

 需要注意如下几点：

1) 模块是按照一定顺序排列的。如果打破默认序列，EFI文件不可用。  （但是，我下面的方法用了所有的模块，也可以启动，没有按照特定的顺序。）

2) fat必须被添加到EFI文件中，用以从FAT文件系统中寻找后续启动文件。

3) grub2-mkstandalone是grub2-mkimage功能的延伸，可以增加任何文件，甚至文件夹到EFI文件中，具体细节可参考grub2-mkstandalone -h。

https://stackoverflow.com/questions/35269943/how-does-the-grub2-uefi-loader-know-where-to-look-for-the-configuration-file-or

How does the GRUB2 UEFI loader know where to look for the configuration file (or where the 2nd stage's files are located)?

此文讲的非常好。

=============


There are actual several ways this can happen:

    Load an embedded config file.
    Load a config file in the same directory as the GRUB binary.
    Load a config file from a path decided at grub-mkimage (called by grub-install) execution time.

The latter is probably the functionality you are really asking for - and it's a combination of the default config file name (grub.cfg), the prefix (default /boot/grub, but can be explicitly specified to grub-mkimage) and the grub partition name for the partition where the prefix is located.

If I run strings /boot/efi/EFI/debian/grubx64.efi | tail -1 on my current workstation, it prints out the stored value: (,gpt2)/boot/grub, telling grubx64.efi to look for its configuration file in /boot/grub on GPT partition 2. The bit before the comma (the GRUB disk device name) gets filled in at runtime based on which disk the grubx64.efi image itself was loaded from.

Dynamically loaded modules will also be searched for under this location, but in an architecture/platform-specific directory - in this case /boot/grub/x86_64-efi.




for EFI image, I found that grub-install or grub-mkimage will always embed an early config into the result EFI binary, regardless of whether or not you have specified the --config FILE option. If you do not specify the --config FILE option, it will try to embed /boot/grub/x86-64_efi/load.cfg, This early config file looks like this:

    search.fs_uuid 8ef704aa-041d-443c-8ce6-71ac7e7f30da root hd0,gpt1
    set prefix=($root)'/boot/grub'
    configfile $prefix/grub.cfg  # this line seems can be omitted, because it seems to be the default next action

    The uuid means uuid of file system, not of partition, you can use blkid to list it.
    The hd0,gpt1 is just a hint.
    You can change the first line into set root=hd0,gpt1

This default behavior of auto embedding is different as in BIOS mode, the latter by default only embed a prefix string like (,gpt3)/boot without bothering search.uuid.

I also found that Ubuntu bionic EFI image embedded a early config like this https://source.puri.sm/pureos/core/grub2/blob/master/debian/build-efi-images#L64

if [ -z "\$prefix" -o ! -e "\$prefix" ]; then
    if ! search --file --set=root /.disk/info; then
        search --file --set=root /.disk/mini-info
    fi
    set prefix=(\$root)/boot/grub
fi
if [ -e \$prefix/$platform/grub.cfg ]; then
    source \$prefix/$platform/grub.cfg
elif [ -e \$prefix/grub.cfg ]; then
    source \$prefix/grub.cfg
else
    source \$cmdpath/grub.cfg
fi

The cmdpath is the DIR of efi binary, so it will fallback to the grub.cfg in the same dir of the efi binary, as you found.


==============


/media/werner/e3e084db-7f7f-47cb-866b-743b7c5758ec1/grubconfig.git/boot/EFI/grub.cfg


首先准备如下文件：
grub-mkimage.cfg 

#/dev/sda2                          vfat                       /mnt/sda2                              EF4B-3153
search.fs_uuid EF4B-3153 root
# 根据情况修改：
set prefix=($root)'/EFI/uefi-hd'
configfile $prefix/grub.cfg

按照观察到的 grub-install 调用 grub-mkimage的 方法，使用下面的即可：

sudo grub-mkimage -c grub-mkimage.cfg -o grubx64.efi -O x86_64-efi -p ''  fat part_msdos 'ext2' 'part_gpt' 'search_fs_uuid'



基于 grub-mkstandalone 的独立的 GRUB (可移植的方法)：

ref：
https://wiki.archlinux.org/index.php/GRUB/Tips_and_tricks_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)


echo 'configfile ${cmdpath}/grub.cfg' > /tmp/grub-mkstandalone.cfg
sudo grub-mkstandalone -O x86_64-efi -o grub-mkstandalone-x86_64.efi "boot/grub/grub.cfg=/tmp/grub.cfg"

sudo efibootmgr --create --disk /dev/sda --part 2 --loader /EFI/uefi-hd/grubx64_standalone.efi --label "grubx64_standalone"


独立的 GRUB EFI 文件和这个 grub.cfg 可以存放在 EFI 系统分区中的任何一个目录里，只有它们处在同一个目录中就可以。这样它们就变得可移植了。 

然后，将 grubx64_standalone.efi 和 下面的 grub.cfg 放到一个目录即可：




efibootmgr 使用说明（manpage 所述不详，不如这里。arch的wiki确实有水平。）：
----------------------
https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#efibootmgr

要通过 efibootmgr 添加新的启动参数，需要确认：

    包含 ESP 的磁盘编号: /dev/sdX
    ESP 在第几个分区 /dev/sdXY 中的 Y
    UEFI 程序相对 ESP 根目录的路径

假设要启动的引导器文件是 /boot/efi/EFI/refind/refind_x64.efi,/boot/efi 是 ESP 的挂载目录

$ findmnt /boot/efi

TARGET SOURCE  FSTYPE OPTIONS
/boot/efi /dev/sda1  vfat   rw,flush,tz=UTC

上面结果说明 ESP 位于 /dev/sda，分区编号是 1. UEFI 程序相对于 ESP 根的路径是/EFI/refind/refind_x64.efi. 应该用下面 efibootmgr 语句创建:

# efibootmgr --create --disk /dev/sda --part 1 --loader /EFI/refind/refind_x64.efi --label "rEFInd Boot Manager"

实际测试表明，下面的写法都是有效的：


/EFI/mygrub/grubx64.efi
EFI/mygrub/grubx64.efi
\EFI\mygrub\grubx64.efi
EFI\mygrub\grubx64.efi




参考efibootmgr(8) 或 efibootmgr README。
注意: UEFI 使用反斜杠 \ 作为路径分隔符 (类似于 Windows 路径)，Efibootmgr 解析路径之前内部会把 / 转换为 \.
----------------------


























