#$ sudo blkid -o list |grep /dev/sda3
#/dev/sda3  ext4             /media/werner/e3e084db-7f7f-47cb-866b-743b7c5758ec1 e3e084db-7f7f-47cb-866b-743b7c5758ec

# 观察到的 grub-install 内部会这样调用：

# 分别使用 /usr/sbin/grub-install ， /usr/local/sbin/grub-install 进行 efi安装，加上 -v , 搜索 log。即可。

# grub-mkimage --directory '/usr/local/lib/grub/x86_64-efi' --prefix '(,gpt3)/grubconfig.git/boot/grub' --output '/mnt/sda3/grubconfig.git/boot/grub/x86_64-efi/core.efi'  --dtb '' --format 'x86_64-efi' --compression 'auto'  'ext2' 'part_gpt'

# or

# 我又加了  fat part_msdos 模块。

# sudo /usr/bin/grub-mkimage --directory '/usr/lib/grub/x86_64-efi' --prefix '/grubconfig.git/boot/grub' --output '/mnt/sda3/grubconfig.git/boot/grub/x86_64-efi/core.efi' --format 'x86_64-efi' --compression 'auto'  --config '/mnt/sda3/grubconfig.git/boot/grub/x86_64-efi/load.cfg' fat part_msdos 'ext2' 'part_gpt' 'search_fs_uuid' configfile

# sudo blkid -o list | grep /dev/sda3
# /dev/sda3  ext4             /media/werner/e3e084db-7f7f-47cb-866b-743b7c5758ec1 e3e084db-7f7f-47cb-866b-743b7c5758ec






#grub-mkstandalone 基于 grub-mkimage 的工作方式如下：
#$ sudo grub-mkstandalone -O x86_64-efi -o grub-mkstandalone-x86_64.efi --modules='fat part_msdos part_gpt ext2 regexp iso9660 loopback chain search configfile test normal'  boot/grub/grub.cfg=./grub-mkstandalone.cfg -v |& grep -E 'grub-mkimage'
#grub-mkstandalone: info: grub-mkimage --directory '/usr/lib/grub/x86_64-efi' --prefix '(memdisk)/boot/grub' --output 'grub-mkstandalone-x86_64.efi' --format 'x86_64-efi' --compression 'auto'  --memdisk '/tmp/grub.wXtx3a' 'fat' 'part_msdos' 'part_gpt' 'ext2' 'regexp' 'iso9660' 'loopback' 'chain' 'search' 'configfile' 'test' 'normal' 'memdisk' 'tar'

#man grub-mkimage 有下面的选项：

#       -m,                              --memdisk=FILE
#              embed FILE as a memdisk image

#       Implies `-p (memdisk)/boot/grub' and overrides

#       any prefix supplied previously, but the prefix
#              itself can be overridden by later options

#这正是 grub-mkstandalone 基于 grub-mkimage 的工作方式。

#在这个处理过程中，root=(memdisk)， prefix=(memdisk)/boot/grub

#但是，我的相关文件位于 硬盘，仍然要变化 相应的 root 、prefix 。

#仍然基于  origroot 、origprefix 的方法来解决。

#但是，发现下面的命令并不能捕获到相应的 值：
#root=(memdisk)
#prefix=(memdisk)/boot/grub

#可能这个值已经非常明确了，不需要在环境变量中存储。任何时候都可以通过上面的方式调用。

#set origroot=$root
#set origprefix=$prefix



# 该文件是以下面的命令被调用的：
# 所以，其中的变量设定不会影响环境。
# configfile ${cmdpath}/grug.cfg

# 基于 cmdpath 去寻找相应的 设定：
# 确保 调用本文件的efi 和 后续的 boot 目录 位于同一盘上，从而保证可移植性。

regexp -s rootdisk '^\(([^,]+)' "$cmdpath"



# 用下面的文件来做定位器（placeholder）：
for file in ($rootdisk,*)/boot/grub/mbusb.cfg.local; do
  # 使用 if 的这个判断似乎并非必须的，因为上面的条件已经很具体了。
  # 但是，这样写也没有什么问题。
  if regexp -s rootpart '^(\(.*\))' "$file"; then
    set root=$rootpart
    set prefix=($root)/boot/grub
    # 如果下面的命令是最后一条语句，是可以省略的：
    configfile $prefix/grub.cfg
    
#    set root=$origroot
#    set prefix=$origprefix
    break
  fi
done

