# Some pre-loaded modules：
    insmod part_msdos
    insmod ntfs
    insmod part_gpt
    insmod ext2
    insmod iso9660
    insmod regexp
    insmod loopback
    insmod chain
    insmod gzio

# Add the following for using by FreeBSD. 
# I'm not sure whether these modules is really needed or not, so loaded them just in case:
    insmod ufs2
    insmod zfs
    insmod bsd


# 采用新的命名规范：
# absolute directory name:
# 含设备名的：
# x_abs_dirname=$x_root$x_dirname
# x_abs_name=$x_root$x_name=$x_root$x_dirname$x_basename
# 不含设备名的： 
# x_name=$x_dirname$x_basename
# x_dirname
# x_basename


# Save the original root's value, so we can restore it later easilly：
set origroot=$root

for loader in (*)/boot/vmlinuz-*-amd64          \
              (*)/boot/vmlinuz                  \
              (*)/boot/vmlinuz-linux            \
              (*)/boot/vmlinuz-*-x86_64         \
              (*)/ROOT/default/@/boot/loader.efi; do
  
  # If do the file / directory test on zfs filesystem, grub2 will failed and 
  # finally, the menuentry will not be constructed.
  # So, only do the regexp test on the glob expanded strings to ensure that the corresponding file / directory is found,
  # and don'\''t test on the file / directory itself.
  # Essentially speaking, this is only do a string test with regexp.  It shouldn'\''t have trouble for all 
  # filesystems which grub found.
  # If the regexp module is loaded and the wild expansion is done correctly，the following
  # is enough to ensure that the corresponding device is found:
  if regexp '^\([^*]+\)' "$loader"; then
    regexp -s 1:loader_root -s 2:loader_dirname -s 3:loader_basename '^(\(.*\))(/.*/)([^/]+)$' "$loader"
    if regexp 'vmlinuz-.*-amd64$' "$loader"; then
      menuentry "Debian GNU/Linux on $loader_root" "$loader_root" "$loader_dirname$loader_basename" {
        # both the following regexp can be used to match the device name：
        # 
        # '^(\(.*\))'
        # '^\((.*)\)' 

        # but the first includes () in the result, while the latter not.
        # In the former case, when invoking the var，shouldn't use () ,
        # the exception is that the var's name is root, in this case, the 
        # () will be stripped automatically.  
        # so ($root) is correct。while ($var) is wrong for the former case. 
  
        set root=$2
        set vmlinuz_name=$3
        probe --set root_uuid --fs-uuid $root
        regexp -s initrd_name '^(.*)$' /boot/initrd.img-*-amd64    
    
        linux  $vmlinuz_name root=UUID=$root_uuid ro  
        initrd  $initrd_name
        # 还原变量设定，菜单中其他的条目才能使用相关的默认配置文件：
        set root=$origroot

        #https://www.gnu.org/software/grub/manual/grub/grub.html#boot
        #16.3.8 boot
        #Command: boot
        # Boot the OS or chain-loader which has been loaded. 
        # Only necessary if running the fully interactive command-line (it is implicit at the end of a menu entry). 
      }

    elif regexp 'vmlinuz$' "$loader"; then
      menuentry "Ubuntu on $loader_root" "$loader_root" "$loader_dirname$loader_basename" {
        set root=$2
        set vmlinuz_name=$3
        probe --set root_uuid --fs-uuid $root
        regexp -s initrd_name '^(.*)$' /boot/initrd.img   
    
        linux  $vmlinuz_name root=UUID=$root_uuid ro  
        initrd  $initrd_name
        set root=$origroot     
      }
    elif regexp 'vmlinuz-linux$' "$loader"; then
      menuentry "Arch Linux on $loader_root" "$loader_root" "$loader_dirname$loader_basename" {
        set root=$2
        set vmlinuz_name=$3
        probe --set root_uuid --fs-uuid $root
        regexp -s initrd_name '^(.*)$' /boot/initramfs-linux.img     
    
        linux  $vmlinuz_name root=UUID=$root_uuid ro  
        initrd  $initrd_name
        set root=$origroot    
      }
    elif regexp 'vmlinuz-.*-x86_64$' "$loader"; then
      menuentry "Manjaro Linux on $loader_root" "$loader_root" "$loader_dirname$loader_basename" {
        set root=$2
        set vmlinuz_name=$3
        probe --set root_uuid --fs-uuid $root
        regexp -s initrd_name '^(.*)$' /boot/initramfs-*-x86_64-fallback.img     
    
        linux  $vmlinuz_name root=UUID=$root_uuid ro  
        initrd  $initrd_name
        set root=$origroot    
      }
    # If FreeBSD is installed on more than one partitions, 
    # it seems that only the first one found can be booted successfully,
    # though all of them may be found by this script. 
    elif regexp '/ROOT/default/@/boot/loader[.]efi$' "$loader"; then 
      menuentry "FreeBSD on $loader_root" "$loader_root" "$loader_dirname$loader_basename" {
        loader_root="$2"
        loader_name="$3"  
        set root=$loader_root
        chainloader $loader_name 
        boot
        set root=$origroot
      }      
    fi

  fi
done

   




### BEGIN /usr/local/etc/grub.d/41_custom ###
if [ -f  ${config_directory}/custom.cfg ]; then
  source ${config_directory}/custom.cfg
elif [ -z "${config_directory}" -a -f  $prefix/custom.cfg ]; then
  source $prefix/custom.cfg;
fi
### END /usr/local/etc/grub.d/41_custom ###






